---
title: Mysql锁
tags: []
id: '589'
categories:
  - - 未分类
---

## 锁的范围划分

全局锁 可用于库备份，但是会导致写入停止

```sql
flush tables with read lock
```

表级锁 锁表后，同一张表只能有一个写入，Myisam和Innodb均有此概念 NDL锁：元数据锁，优化行级锁的时候，如果涉及整表的改动就不需要遍历行锁标记了 行级锁 select for update 会加上一个写锁一个读锁（元数据锁），事务进行中，无法修改表结构，直到锁释放 记录锁 - 锁住某一条记录 间隙锁 - 防止幻读，锁住记录与记录之间的间隙，比如 id=10和id=15其中就有间隙 Next-Key 锁，记录锁+间隙锁 插入意向锁

## 锁的兼容性

共享锁 - 读锁(S) select lock in share mode，为某行加读锁，可以同时加 独占锁 - 写锁(X) select lock in for update; 加独占锁，无法与其他锁共存，比如有读锁的情况，就无法写入

## 死锁

使用 `show engine` 比如事务A拿到 id in (1, 2)读锁，事务B拿 id in (2, 3) 的读锁，然后事务B期望拿到 id = 2 的写锁(update)，因为事务A有读锁，所以阻塞了；然后事务A希望拿到 id = 3 的写锁(update)，就卡住了

## 二阶段锁协议

查询能加锁，但是释放锁却需要等待查询事务的提交 减库存 1. 查询现有库存是否充足 2. 库存充足减库存，不足扣除失败

```sql
update stock set last_number = last_number - 1 where id = 100 and last_number > 1
```

## 完整锁解决

在读取的时候加上 for update 拿到写锁，以便后续更改

## 乐观锁

CAP 处理速度快，并发高的话，会有很多执行失败的情况

## 悲观锁

S 和 X 都是悲观锁，因为会阻止加上其他锁

### 主键等值查询

select lock in share mode; 首先加 next-key，发现是唯一索引的等值查询，找到对应数据，会退化为记录锁，没找到会变成间隙锁

### 无索引等值查询

演变为表级锁，尽量避免查询打不到索引

## 主键范围查询

lock for share mode 锁间隙

## 无索引范围

依旧表锁

## 普通二级索引

修改/查询 有二级索引的字段，二级索引加锁 修改行都会在聚簇索引上加锁 锁是加到对应索引上面的