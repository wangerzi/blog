---
title: 【软考知识总结】计算机组成结构
tags:
  - 计算机组成结构
  - 软考
id: '721'
categories:
  - - 基础知识
date: 2022-03-27 20:11:43
cover: /static/uploads/2022/04/nick-morrison-FHnnjk1Yj7Y-unsplash-1200x661.jpg
---

## 前言

本章主要包含计算机硬件组成，CPU 、计算机各个组件，部分信息加密，安全等等

### 章节大纲

计算机系统

*   硬件组成
*   CPU
*   数据表示
*   校验码

体系结构

*   指令
*   存储
*   输入输出
*   总线

安全性可靠性

*   可靠性分析
*   安全
*   加密和认证

其中 **数据表示、校验码、加密是重点**

## 计算机系统

### 硬件组成

硬件五大部分，**运算器，控制器，存储器，输入设备和输出设备**

### CPU

CPU 由运算器，控制器，寄存器和内部总线组成 运算器由 算术逻辑单元 ALU，累加寄存器 AC（临时存储逻辑运算数据），数据缓冲寄存器 DR，状态条件寄存器 PSW 组成，用于执行加减乘除和逻辑运算。 控制器由指令寄存器 IR，程序计数器 PC（存放指令地址），地址寄存器 AR，指令译码器 ID，用于程序控制和时序控制。

### 数据表示

十进制转 R进制，取余然后从下往上排列即可。 M转N进制，用十进制中转即可。 原码：数的正常二进制表示 反码：负数的反码取反，即为对应的数值 补码：负数的补码取反加一 移码： 常用于表示浮点数中的阶码（0.123 \* 10^3），这个 3 就是阶码，包含1个符号位和n个数值位，特点是方便比大小 移码计算：偏移量为 2^n - 1，真值（整数）+偏移量即为移码的表示 比如补码 0111 1110，其移码表示 0111 1110 + 0111 1111 = 1011 1101 浮点数规格化的意思就类似 0.12\*10^3，二进制上的表现就是 0.101011 \* 2^n，小数后第一位不为0，这时候阶码才是对齐的 《阶码，尾数，移码》https://www.jianshu.com/p/180baf2e88d4 移码怎么算啊～? https://www.zhihu.com/question/491056632/answer/2234280842 小数的范围直接除以 2^(n-1)，因为留一个1在小数点前，其他的数用二进制表示，补码和移码范围一致 [![](/static/uploads/2022/03/wp_editor_md_a6f983f8bee6e20646fe2a1f09afe9f1.jpg)](/static/uploads/2022/03/wp_editor_md_a6f983f8bee6e20646fe2a1f09afe9f1.jpg) 字长指的是 CPU 能同时处理和传输的位数，字(word)用于表示一次性处理事务的固定长度，字的位数就是字长。 浮点数表示法：N = F \* 2^E，F 为尾数，E为阶码，类似 101.011 = 0.101011 \* 2^3 浮点数由 阶符 + 阶码 + 数符 + 尾数组成，范围由阶码确定，数值精度由尾数确定 规格化表示里，正数的补码为 0.1xxx，负数的补码应为 1.0xxx（取反+1后，第一个小数位还是1） 对阶，两个数的阶码需要相同，小阶码向大阶码看起，阶码加几位，尾数右移几位，注意溢出。 结果做规格化，尾数就可以直接相加 如果阶码（包括阶符）由 R 位移码表示，尾数（包括数符）由 M 位补码表示，则浮点数数值范围： 最大正数：(1-2(-M+1))\*2^(2^(R-1) -1) 最小负数：-1\*2^(2^(R-1) -1)

### 校验码

码距指编码 A -> 编码 B 需要改变的位的数，比如 00->01 的码距为1，因为只改变一位

#### 奇偶校验码

奇偶校验码，指的是多一个位来使1的个数为奇数或者偶数，相当于把变化的码距由1变为2，只能校验正确性不能纠错，但有问题，比如刚好改了两个位，奇偶校验是看不出来的。

#### CRC 校验（重点）

CRC 校验，只能校验不能纠错，原理是把原码除以本源多项式，所得余数即为 CRC 校验码。 实际做题会比较简单，直接拿着数字除即可，多项式有n位，原码后补充 n-1 个0，CRC 结果也需要补齐到 n-1 位，左侧补0。 [![](/static/uploads/2022/03/wp_editor_md_84dbaf55fafed13ce4f4aa5fa27e92f3.jpg)](/static/uploads/2022/03/wp_editor_md_84dbaf55fafed13ce4f4aa5fa27e92f3.jpg) 参考：https://blog.csdn.net/u013073067/article/details/86621770

#### 海明码（重点）

海明码：原理是通过奇偶校验位，以及固定位填充数据扩大码距，从而达到校验和纠错的目的。 校验位于从低往高数，2^n 方位都是校验位，从0次方开始，1/2/4/8/16，其余位用于填充数据。 基于这个原理有个结论，海明码的校验位 k，数据位 n 满足 2^k > n+k，因为 2^k 是临界点，对应下一个校验码。 具体的算法就是，每一个校验位对应 2^k，那么其左侧的包含 2^k 的所有数据都要拿过来做顺序的疑惑，详见截图。 位于从右往左数位于第四位的校验码，即为 5/6/7 这三个位的值异或而来，1 xor 0 = 1, 1 xor 1 =0，也可以理解为奇数个 1为1，偶数个1 为0，因为 5 = 4 + 1, 6 = 4 + 2, 7 = 4 + 2 + 1 同理，位于从右往左数位于第二位的校验码，就要找解构后包含 2 的位，即为 3/6/7 异或而来，所以为0 再同理，位于第一位的校验码，找解构后包含1的位，即 3/5/7 异或而来，所以为 1 如果接收方发现数据位算出来的校验位非全0（因为算上校验位和校验位对应的位，一定是偶数个1），那么接收方拿到的校验位，比如是 100，那么就说明第 4 位数据有误，需要翻转。 为啥只有一位呢，因为错误的那个位，对应的所有校验位都是错的，比如 7 错了，那么包含他的校验位 4/2/1 都会错，因为 7 = 4 + 2 + 1，而 4/2/1 都错，也就是 111 相当于对应的 2^n 方拼接起来 4 + 2 + 1 = 7。 但这样只能纠错一位，如果两个位都错了，得出来的结果就有问题了。 [![](/static/uploads/2022/03/wp_editor_md_2d817c91509a4f094a5c4a84b5070826.jpg)](/static/uploads/2022/03/wp_editor_md_2d817c91509a4f094a5c4a84b5070826.jpg)

## 体系结构

[![](/static/uploads/2022/03/wp_editor_md_b945e950bea9af4769b7eec7a54d6c99.jpg)](/static/uploads/2022/03/wp_editor_md_b945e950bea9af4769b7eec7a54d6c99.jpg) Flynn 分类法，两个指标，指令流和数据流，指令 Instruction，数据 Data，单 Sing，多 M，所以分为 SISD/SIMD/MISD/MIMD 四种类型。 指令对应的是控制部分，数据对应的是处理器，而内存模块是只要指令和数据存在一个是多个，那么就需要是多个。 所以多指令，单数据这个模型不实际，因为指挥者有多个，数据处理却只有一个，但对应后端关联一下，nodejs 这种事件轮询机制，redis 这种单线程处理请求的模式却有点像这个特点。

### 指令

指令由操作码和操作数组成，指令执行过程，**取指->分析->执行** 指令寻址 - 顺序，直接从 PC（程序计数器）一条条读取 - 跳跃，特殊的 jump 操作码，跳转到指定的指令上 操作数寻址 - 立即寻址，操作数即为值 - 直接寻址，给到主存地址 - 间接寻址，给到主存地址，其主存对应存放值的真实地址 - 寄存器寻址，存寄存器编号 **重点** 指令系统，CISC（复杂指令集），RISC（精简指令集） 特点 - CISC 指令数量多，使用频率差距大，可变格式，多种寻址方式，微程序控制实现，成本高 - RISC 指令数量少，使用频率差不多，格式少，寻址方式少，寄存器多，硬件实现逻辑，适合指令流水线，可以进行编译优化，支持高级语言 **指令流水线**是指 取指->分析->执行 这三个过程可以叠加在同一时间并行执行，A指令分析时，B指令就可以取指了。 [![](/static/uploads/2022/03/wp_editor_md_8c16b555640c3af36ba8412610ec6600.jpg)](/static/uploads/2022/03/wp_editor_md_8c16b555640c3af36ba8412610ec6600.jpg) [![](/static/uploads/2022/03/wp_editor_md_bbb5846df264a1901c7304ed0c0a9da1.jpg)](/static/uploads/2022/03/wp_editor_md_bbb5846df264a1901c7304ed0c0a9da1.jpg) 流水线周期，指的是 取指->分析->执行 中最长过程的执行事件，因为这三个执行过程会相互影响和等待。 指令执行时间，n个指令的总执行时间为 一个完整的指令执行时间 + (n-1) \* 流水线周期 吞吐率，指令执行数量/指令执行时间 加速比，不适用流水线时间/用了流水线的时间 如果有超标量流水线，比如同时能3个一起执行，那么总执行时间为 一个完整指令执行时间 + ceil((n-1)/3) \* 流水线周期

### 存储

金字塔型是为了解决容量和速度的矛盾，从上到下，容量+，速度-。 [![](/static/uploads/2022/03/wp_editor_md_e3b42870efdfe091c7ab3f2b59cad144.jpg)](/static/uploads/2022/03/wp_editor_md_e3b42870efdfe091c7ab3f2b59cad144.jpg) 为什么要做缓存，因为存储有局部性原理，也就是 CPU 在运行时，会倾向于访问较小的局部空间地址。

*   时间局部性原理，如果一个数据项正在被访问，不短的将来，可能会被再次访问
*   空间局部性原理，一个数据被访问，与之相邻的数据可能被再次访问

[![](/static/uploads/2022/03/wp_editor_md_7ba587b9bd8ea27d8f35bab270ded191.jpg)](/static/uploads/2022/03/wp_editor_md_7ba587b9bd8ea27d8f35bab270ded191.jpg) 因为 CPU 访问 cache 的时候，用的是主存地址，那么缓存需要将主存地址映射到自己的空间内以查看是否存在，**这个映射由硬件完成**，主要有如下几种方案。

*   直接映射法，将主存分为 M个区和 N个块，缓存也分块分组，直接对应到主存的某块内存，缺点是浪费资源，因为有些分组可能用得很少
*   全相连映射法，主存直接分块，缓存记录这是在主存的哪个块，可以随意映射，缺点是慢，但不容易冲突
*   组相连映射法，结合上述两者，先给主存和缓存分组分块，然后在每一组内，进行不固定块的全相联映射，确保一个组内尽可能高的利用率，但又不至于数据规模过大导致缓存读写缓慢。

#### 存储相关的计算

如何计算主存容量呢，容量 = 内存单元 \* N字节编址，做下单位转换即可 需要用多少存储芯片，主存容量除以存储芯片容量即可 [![](/static/uploads/2022/03/wp_editor_md_16cfe339b8013e72cdc52b643360a3b8.jpg)](/static/uploads/2022/03/wp_editor_md_16cfe339b8013e72cdc52b643360a3b8.jpg)

### 总线

[![](/static/uploads/2022/03/wp_editor_md_5ffa2c30408396365382bba6b21826d6.jpg)](/static/uploads/2022/03/wp_editor_md_5ffa2c30408396365382bba6b21826d6.jpg) 总线分三类

*   内部总线，芯片级别总线，芯片与处理器间通信的总线
*   系统总线，连接各个组件
    *   数据总线，并行处理数据的大小
    *   地址总线，可管理内存的大小
    *   控制总线，传递控制命令
*   外部总线，设备一级的，SCSI/USB 等

## 安全性可靠性

### 可靠性分析

平均无故障时间 MTTF = 1/失效率 平均故障修复时间 MTTR = 1/修复率 平均故障间隔 MTBF = MTTF + MTTR 系统可用性 MTTF/(MTTF + MTTR) \* 100% 串联、并联、混合，串联是一个不可靠，全都不可靠，并联是全部不可靠才会让系统不可靠，混合就是两个可靠性公式组合在一起。 串：R=R1\*R2; 并：R=1- (1-R1)\*(1-R2) 混：R=R1\*(1- (1-R2)\*(1-R3)) [![](/static/uploads/2022/03/wp_editor_md_55b130ee0d8498c57aec83e722f2c04c.jpg)](/static/uploads/2022/03/wp_editor_md_55b130ee0d8498c57aec83e722f2c04c.jpg)

### 网络安全

网络安全五要素

*   保密性，最小授权，信息加密，物理加密
*   完整性，传输正确无误
*   可用性，合法用户能以合法的方式访问数据
*   可控性，控制授权范围内信息流向及行为方式
*   不可抵赖性，信息参与者不能否认自己的行为，参与者身份真实有效

网络安全分类

*   **重放攻击 ARP**
*   **拒绝服务 DOS**
*   窃听
*   业务流分析
*   信息泄露
*   破坏信息完整
*   非授权访问
*   假冒
*   **旁路攻击**
*   **授权侵犯，不是按照设计的授权去做应该做的事**
*   **木马**
*   陷阱门，隐藏逻辑
*   抵赖（侵犯不可抵赖性）

### 加密和认证

[![](/static/uploads/2022/03/wp_editor_md_b22cc0090d422d64a5ad28256094e045.jpg)](/static/uploads/2022/03/wp_editor_md_b22cc0090d422d64a5ad28256094e045.jpg) 常见对称加密算法：

*   DES
*   3DES
*   **AES**
*   RC-5
*   IDEA 算法

常见非对称算法：

*   **RSA**
*   PGP
*   ECC 椭圆曲线
*   Elgamal
*   背包算法、Rabin、D-H 等

[![](/static/uploads/2022/03/wp_editor_md_a2c50d6b4cc87a749797bb3ec965de01.jpg)](/static/uploads/2022/03/wp_editor_md_a2c50d6b4cc87a749797bb3ec965de01.jpg)

##### 数字签名

基于非对称加密，信息发送方私钥加密报文签名，公钥公开出去，接收方用公钥解密得到可信的报文签名即可。 由 CA 认证过的数字证书，以避免信息发送方的公钥私钥被替换，用户会从 CA 下载公钥，并用 CA 的公钥验证真实性。 PKI 公钥基础设施 KMC(Key Mangement Center,密钥管理中心) KMI，由 KMC 提供的密钥管理服务 三大功能 - 核实发送者报文签名，验证来源真实姓 - 发送方无法抵赖对报文的签名 - 数据摘要能正常的被公钥解密则表明未被篡改

## 总结

计算机组成结构是比较重点的一个章节，分值比较高，主要复习大学时期组成原理以及部分网络原理的内容。